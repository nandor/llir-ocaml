# 2 "asmcomp/genm/emit.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                 Nandor Licker, University of Cambridge                 *)
(*                                                                        *)
(*   Copyright 2018--     Nandor Licker                                   *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Specific operations for the GenM processor *)

open Arch
open Cmm
open Mach
open Linearize
open Emitaux
open Reg

type alloc_site = { gc_lbl: label; gc_ret: label }

let items = ref []

let emit_symbol s = Emitaux.emit_symbol '_' s

let emit_float f = emit_string (string_of_float f)

let emit_linear fast body =
  let gc_sites = ref [] in

  (* Find the next available virtual register *)
  let next_reg = ref 0 in
  let params = Hashtbl.create 10 in
  let rec find_regs i =
    let max_reg = function
      | { loc = Reg r } ->
        let n =  Proc.num_available_registers.(0) in
        if r >= n then begin
          match r land 7 with
          | 0 -> (* argument *) ()
          | 1 -> (* param *)    Hashtbl.replace params r ((r - n) lsr 3)
          | 2 -> (* result *)   ()
          | _ -> assert false
        end else
          next_reg := max (r + 1) !next_reg;
      | { loc = Unknown } -> failwith "reg: unknown"
      | { loc = Stack _ } -> failwith "reg: stack"
    in
    i.arg |> Array.iter max_reg;
    i.res |> Array.iter max_reg;
    if i.desc <> Lend then find_regs i.next
  in
  find_regs body;
  params |> Hashtbl.iter (fun arg idx ->
    `  arg.i64 ${emit_int arg}, {emit_int idx}\n`
  );

  let make_temp () = let n = !next_reg in next_reg := n + 1; n in
  let emit_temp n = emit_string ("$" ^ (string_of_int n)) in

  let emit_const n =
    let reg = make_temp () in
    `  imm.i64 {emit_temp reg}, {emit_int n}\n`;
    reg
  in

  let emit_cc cc =
    let cc_str = match cc with
      | Isigned   Ceq -> "eq"
      | Isigned   Cne -> "ne"
      | Isigned   Clt -> "lt_s"
      | Isigned   Cgt -> "gt_s"
      | Isigned   Cle -> "le_s"
      | Isigned   Cge -> "ge_s"
      | Iunsigned Ceq -> "eq"
      | Iunsigned Cne -> "ne"
      | Iunsigned Clt -> "ls_u"
      | Iunsigned Cgt -> "gt_u"
      | Iunsigned Cle -> "le_u"
      | Iunsigned Cge -> "ge_u"
    in emit_string cc_str
  in

  let emit_reg = function
    | {loc = Reg r} ->
      emit_string ("$" ^ (string_of_int r))
    | _ ->
      assert false
  in

  let emit_regs regs =
    let n = Array.length regs in
    Array.iteri (fun i reg ->
      emit_reg reg;
      if i + 1 <> n then emit_string ", "
    ) regs
  in

  let emit_label lbl =
    emit_string ".BB"; emit_int lbl
  in

  let emit_op arg res = function
    | Imove ->
      failwith "  move\n"
    | Ispill -> assert false
    | Ireload -> assert false
    | Iconst_int(_) ->
      failwith "  const_int\n"
    | Iconst_float(_) ->
      failwith "  const_float\n"
    | Iconst_symbol(_) ->
      failwith "  const_symbol\n"
    | Icall_ind _ ->
      let nres = Array.length res in
      let types = String.concat "" (List.init nres (fun _ -> ".i64")) in
      `  call{emit_string types} {emit_regs res}, {emit_regs arg} @caml_call_frame\n`;
    | Icall_imm(_) ->
      failwith "  call_imm\n"
    | Itailcall_ind(_) ->
      `  tcall {emit_regs arg}\n`
    | Itailcall_imm { func } ->
      let addr = make_temp () in
      `  addr.i64 {emit_temp addr}, {emit_symbol func}\n`;
      `  tcall {emit_temp addr}, {emit_regs arg}\n`
    | Iextcall(_) ->
      failwith "  extcall\n"
    | Istackoffset(_) ->
      failwith "  stackoffset\n"
    | Iload(size, addr) ->
      let instr = match size with
        | Byte_unsigned      -> "1.u64"
        | Byte_signed        -> "1.s64"
        | Sixteen_unsigned   -> "2.u64"
        | Sixteen_signed     -> "2.s64"
        | Thirtytwo_unsigned -> "4.u64"
        | Thirtytwo_signed   -> "4.s64"
        | Word_int           -> "8.u64"
        | Word_val           -> "8.u64"
        | Single             -> assert false
        | Double             -> assert false
        | Double_u           -> assert false
      in
      (match addr with
      | Iindexed(0) ->
        `  ld.{emit_string instr} {emit_reg res.(0)}, [{emit_reg arg.(0)}]\n`
      | Iindexed(n) ->
        let imm = emit_const n in
        let addr = make_temp () in
        `  add.i64 {emit_temp addr}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  ld.{emit_string instr} {emit_reg res.(0)}, [{emit_temp addr}]\n`
      )
    | Istore(size, addr, _) ->
      let instr = match size with
        | Byte_unsigned      | Byte_signed        -> "1.i64"
        | Sixteen_unsigned   | Sixteen_signed     -> "2.i64"
        | Thirtytwo_unsigned | Thirtytwo_signed   -> "4.i64"
        | Word_int           | Word_val           -> "8.i64"
        | Single   -> assert false
        | Double   -> assert false
        | Double_u -> assert false
      in
      (match addr with
      | Iindexed(0) ->
        `  st.{emit_string instr} [{emit_reg arg.(1)}], {emit_reg arg.(0)}\n`
      | Iindexed(n) ->
        let imm = emit_const n in
        let addr = make_temp () in
        `  add.i64 {emit_temp addr}, {emit_reg arg.(1)}, {emit_temp imm}\n`;
        `  st.{emit_string instr} [{emit_temp addr}], {emit_reg arg.(0)}\n`
      );
    | Ialloc { words } ->
      if fast then begin
        let gc_ret = new_label () in
        let gc_lbl = new_label () in
        `{emit_label gc_ret}:\n`;
        let addr_young_lim = make_temp () in
        let addr_young_ptr = make_temp () in
        let young_lim = make_temp () in
        let young_ptr = make_temp () in
        let new_ptr = make_temp () in
        let flag = make_temp () in
        let immw = emit_const words in
        `  addr.i64 {emit_temp addr_young_lim}, {emit_symbol "caml_young_limit"}\n`;
        `  ld.8.i64 {emit_temp young_lim}, [{emit_temp addr_young_lim}]\n`;
        `  addr.i64 {emit_temp addr_young_ptr}, {emit_symbol "caml_young_ptr"}\n`;
        `  ld.8.i64 {emit_temp young_ptr}, [{emit_temp addr_young_ptr}]\n`;
        `  sub.i64 {emit_temp new_ptr}, {emit_temp young_ptr}, {emit_temp immw}\n`;
        `  setlt.i64 {emit_temp flag}, {emit_temp new_ptr}, {emit_temp young_lim}\n`;
        `  jt {emit_temp flag}, {emit_label gc_lbl}\n`;
        let imm8 = emit_const 8 in
        `  add.i64 {emit_reg res.(0)}, {emit_temp young_ptr}, {emit_temp imm8}\n`;
        gc_sites := { gc_lbl; gc_ret } :: !gc_sites
      end else begin
        failwith "Ialloc";
      end
    | Iintop(_) ->
      failwith "  intop\n"
    | Iintop_imm(_) ->
      failwith "  intop_imm\n"
    | Inegf ->
      failwith "  negf\n"
    | Iabsf ->
      failwith "  absf\n"
    | Iaddf ->
      failwith "  addf\n"
    | Isubf ->
      failwith "  subf\n"
    | Imulf ->
      failwith "  mulf\n"
    | Idivf ->
      failwith "  divf\n"
    | Ifloatofint ->
      failwith "  floatofint\n"
    | Iintoffloat ->
      failwith "  intoffloat\n"
    | Ispecific(_) ->
      failwith "  specific\n"
    | Iname_for_debugger(_) ->
      failwith "  name_for_debugger\n"
  in
  let emit_instr arg res = function
    | Lend ->
      ()
    | Lop(Imove) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`
    | Lop(Iconst_int n) ->
      `  imm.i64 {emit_reg res.(0)}, {emit_int (Nativeint.to_int n)}\n`
    | Lop(Iconst_symbol s) ->
      `  addr.i64 {emit_reg res.(0)}, {emit_symbol s}\n`
    | Lop(op) ->
      emit_op arg res op
    | Lreloadretaddr ->
      ()
    | Lreturn ->
      let nargs = Array.length arg in
      let types = String.concat "" (List.init nargs (fun _ -> ".i64")) in
      `  ret{emit_string types} {emit_regs arg}\n`;
    | Llabel(label) ->
      `{emit_label label}:\n`
    | Lbranch(label) ->
      `  jmp {emit_label label}\n`
    | Lcondbranch(test, label) ->
      (match test with
      | Itruetest ->
        failwith "  truetest\n"
      | Ifalsetest ->
        failwith "  falsetest\n"
      | Iinttest _cmp ->
        failwith "  inttest\n"
      | Iinttest_imm(cc, n) ->
        let imm = emit_const n in
        let flag = make_temp () in
        `  set{emit_cc cc}.i64 {emit_temp flag}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Ifloattest _cmp ->
        failwith "  floattest\n"
      | Ioddtest ->
        failwith "  oddtest\n"
      | Ieventest ->
        failwith "  eventest\n"
      );
    | Lcondbranch3(_lb1, _lb2, _lb3) ->
      failwith "  cond_br_3\n"
    | Lswitch(_labels) ->
      failwith "  switch\n"
    | Lsetuptrap(_label) ->
      failwith "  setup_trap\n"
    | Lpushtrap ->
      failwith "  push_trap\n"
    | Lpoptrap ->
      failwith "  pop_trap\n"
    | Lraise(raise) ->
      (match raise with
      | Cmm.Raise_withtrace ->
        let exn = make_temp () in
        `  addr.i64 {emit_temp exn}, {emit_symbol "caml_raise_exn"}\n`;
        `  tcall {emit_temp exn}, {emit_regs arg} @caml_raise_frame\n`;
      | Cmm.Raise_notrace ->
        failwith "Cmm.Raise_notrace"
      )
  in
  let rec emit = function
    | { desc = Lend } -> ()
    | instr ->
      emit_instr instr.arg instr.res instr.desc;
      emit instr.next
  in
  emit body;
  !gc_sites |> List.iter (fun { gc_lbl; gc_ret } ->
    `{emit_label gc_lbl}:\n`;
    let addr = make_temp () in
    `  addr.i64 {emit_temp addr}, {emit_symbol "caml_call_gc"}\n`;
    `  call {emit_temp addr} @caml_gc_frame\n`;
    `  jmp {emit_label gc_ret}\n`
  )

let data = function
  | [] -> ()
  | data -> items := List.append !items [data]

let fundecl f =
  `\n\nfunction {emit_symbol f.fun_name} \{\n`;
  emit_linear f.fun_fast f.fun_body;
  `}\n`

let begin_assembly () =
  ``

let end_assembly () =
  let globals = ref [] in

  (* Emit a data section with all structures *)
  `\n\ndata \{`;
  !items |> List.iter (fun items ->
      `\n`;
      items |> List.iter (fun item -> match item with
      | Cglobal_symbol s   -> globals := s :: !globals
      | Cstring s          -> emit_string_directive "    string  " s
      | Cskip n            -> if n > 0 then `    space   {emit_int n}\n`
      | Cdefine_symbol s   -> `  {emit_symbol s}:\n`
      | Calign n           -> `    align   {emit_int n}\n`
      | Cint8 n            -> `    int8    {emit_int n}\n`
      | Cint16 n           -> `    int16   {emit_int n}\n`
      | Cint32 n           -> `    int32   {emit_int (Nativeint.to_int n)}\n`
      | Cint n             -> `    int64   {emit_int (Nativeint.to_int n)}\n`
      | Csymbol_address s  -> `    addr    {emit_symbol s}\n`
      | Csingle f          -> `    float32 {emit_float f}\n`
      | Cdouble f          -> `    float64 {emit_float f}\n`
      )
  );
  `}\n`;

  (* Emit a list of all global symbols *)
  `\n\nglobals \{\n`;
  !globals |> List.iter (fun global -> `  {emit_symbol global}\n`);
  `}\n`
