# 2 "asmcomp/genm/emit.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                 Nandor Licker, University of Cambridge                 *)
(*                                                                        *)
(*   Copyright 2018--     Nandor Licker                                   *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Specific operations for the GenM processor *)

open Arch
open Cmm
open Mach
open Linearize
open Emitaux
open Reg

type alloc_site = { gc_lbl: label; gc_ret: label; gc_exc: int list }

let emit_symbol s = emit_string "_"; Emitaux.emit_symbol '$' s

(* Flag to enable inlining small allocations *)
let inline_alloc = ref false
(* Flag to enable inlining exception throwing statements *)
let inline_raise = ref false

let emit_label lbl = emit_string ".L"; emit_int lbl

let emit_linear fast body =
  let bound_error_labels = ref [] in
  let gc_sites = ref [] in

  (* Find the next available virtual register *)
  let next_reg = ref 0 in
  let params = Hashtbl.create 10 in
  let rec find_regs i =
    let max_reg = function
      | { loc = Reg r; typ } ->
        let ty = match typ with
          | Val | Int | Addr -> "i64"
          | Float -> "f64"
        in
        let n =  Proc.num_available_registers.(0) in
        if r >= n then begin
          match r land 7 with
          | 0 -> (* argument *) ()
          | 1 -> (* param *)    Hashtbl.replace params r (((r - n) lsr 3), ty)
          | 2 -> (* result *)   ()
          | _ -> assert false
        end else
          next_reg := max (r + 1) !next_reg;
      | { loc = Unknown } -> assert false
      | { loc = Stack _ } -> assert false
    in
    i.arg |> Array.iter max_reg;
    i.res |> Array.iter max_reg;
    if i.desc <> Lend then find_regs i.next
  in

  let make_temp () = let n = !next_reg in next_reg := n + 1; n in
  let emit_temp n = emit_string ("$" ^ (string_of_int n)) in

  let emit_const n =
    let reg = make_temp () in
    `  mov.i64 {emit_temp reg}, {emit_int n}\n`;
    reg
  in

  let emit_addr symbol =
    let temp = make_temp () in
    `  mov.i64 {emit_temp temp}, {emit_symbol symbol}\n`;
    temp
  in

  let emit_cc cc =
    let cc_str = match cc with
      | Isigned   Ceq -> "eq"
      | Isigned   Cne -> "ne"
      | Isigned   Clt -> "lt"
      | Isigned   Cgt -> "gt"
      | Isigned   Cle -> "le"
      | Isigned   Cge -> "ge"
      | Iunsigned Ceq -> "eq"
      | Iunsigned Cne -> "ne"
      | Iunsigned Clt -> "uls"
      | Iunsigned Cgt -> "ugt"
      | Iunsigned Cle -> "ule"
      | Iunsigned Cge -> "uge"
    in emit_string cc_str
  in

  let emit_reg = function
    | {loc = Reg r} ->
      emit_string ("$" ^ (string_of_int r))
    | _ ->
      assert false
  in

  let emit_regs regs st en =
    match regs with
    | [| |] -> ()
    | regs ->
      emit_string st;
      let n = Array.length regs in
      Array.iteri (fun i reg ->
        emit_reg reg;
        if i + 1 <> n then emit_string ", "
      ) regs;
      emit_string en
  in

  let emit_temps temps =
    emit_string (String.concat ", " (List.map (fun n -> "$" ^ string_of_int n) temps))
  in

  (* Exception handler stack *)
  let current_block = ref 0 in
  let handlers = ref [] in
  let traps = Hashtbl.create 16 in
  let no_handler () = match !handlers with [] -> true | _ -> false in

  let emit_call = function
    | [] -> emit_string "call"
    | _ -> emit_string "invoke"
  in

  let emit_handler = function
    | [] -> ()
    | h :: _ -> `, {emit_label h}`
  in

  let emit_intop res lhs rhs op =
    let emit inst =
      `  {emit_string inst}.i64 {emit_reg res.(0)}, {emit_reg lhs.(0)}, {rhs ()}\n`
    in
    match op with
    | Iadd    -> emit "add"
    | Isub    -> emit "sub"
    | Imul    -> emit "mul"
    | Imulh   ->
      let rega = make_temp () in
      let regb = make_temp () in
      let regr = make_temp () in
      let regc = make_temp () in
      `  sext.i128 {emit_temp rega}, {emit_reg lhs.(0)}\n`;
      `  sext.i128 {emit_temp regb}, {rhs ()}\n`;
      `  mul.i128 {emit_temp regr}, {emit_temp rega}, {emit_temp regb}\n`;
      `  mov.i8 {emit_temp regc}, 64\n`;
      `  srl.i128 {emit_temp regr}, {emit_temp regr}, {emit_temp regc}\n`;
      `  trunc.i64 {emit_reg res.(0)}, {emit_temp regr}\n`
    | Idiv    -> emit "div"
    | Imod    -> emit "rem"
    | Iand    -> emit "and"
    | Ior     -> emit "or"
    | Ixor    -> emit "xor"
    | Ilsl    -> emit "sll"
    | Ilsr    -> emit "srl"
    | Iasr    -> emit "sra"
    | Icomp cc ->
        `  cmp.{emit_cc cc}.i64 {emit_reg res.(0)}, {emit_reg lhs.(0)}, {rhs ()}\n`;
    | Icheckbound _ ->
      let handler = match !handlers with [] -> None | h :: _ -> Some h in
      let label = match List.assoc_opt handler !bound_error_labels with
        | None ->
          let label = new_label () in
          bound_error_labels := (handler, label) :: !bound_error_labels;
          label
        | Some label ->
          label
      in
      let flag = make_temp () in
      `  cmp.le.i32 {emit_temp flag}, {emit_reg lhs.(0)}, {rhs ()}\n`;
      `  jt {emit_temp flag}, {emit_label label}\n`
  in

  let emit_op arg res = function
    | Imove   -> assert false
    | Ispill  -> assert false
    | Ireload -> assert false
    | Iconst_int(n) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_int (Nativeint.to_int n)}\n`;
    | Iconst_float(f) ->
      `  mov.f64 {emit_reg res.(0)}, {emit_printf "0x%Lx" f}\n`;
    | Iconst_symbol(s) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_symbol s}\n`;
    | Icall_ind _ ->
      let nres = Array.length res in
      let types = String.concat "" (List.init nres (fun _ -> ".i64")) in
      `  {emit_call !handlers}{emit_string types}.ocaml{emit_regs res " " ","} {emit_regs arg " " ""}{emit_handler !handlers} @caml_call_frame\n`
    | Icall_imm { func } ->
      let nres = Array.length res in
      let types = String.concat "" (List.init nres (fun _ -> ".i64")) in
      let addr = make_temp () in
      `  mov.i64 {emit_temp addr}, {emit_symbol func}\n`;
      `  {emit_call !handlers}{emit_string types}.ocaml{emit_regs res " " ","} {emit_temp addr}{emit_regs arg ", """}{emit_handler !handlers} @caml_call_frame\n`
    | Itailcall_ind(_) ->
      `  tcall.i64.ocaml {emit_regs arg " " ""}\n`
    | Itailcall_imm { func } ->
      let addr = make_temp () in
      `  mov.i64 {emit_temp addr}, {emit_symbol func}\n`;
      `  tcall.i64.ocaml {emit_temp addr}{emit_regs arg ", " ""}\n`
    | Iextcall { func; alloc } ->
      let nres = Array.length res in
      let res_types = String.concat "" (List.init nres (fun _ -> ".i64")) in
      let addr = make_temp () in
      `  mov.i64 {emit_temp addr}, {emit_symbol func}\n`;
      if alloc then begin
        let wrap = make_temp () in
        let arg_types = arg
          |> Array.map (fun arg -> match arg.typ with
            | Float -> "f64"
            | _ -> "i64"
            )
          |> Array.to_list
          |> String.concat "_"
        in
        `  mov.i64 {emit_temp wrap}, {emit_symbol "caml_c_call_"}{emit_string arg_types}\n`;
        `  {emit_call !handlers}{emit_string res_types}.ext{emit_regs res " " ","} {emit_temp wrap}, {emit_temp addr}{emit_regs arg ", " ""}{emit_handler !handlers}  @caml_call_frame\n`
      end else begin
        `  {emit_call !handlers}{emit_string res_types}.c{emit_regs res " " ","} {emit_temp addr}{emit_regs arg ", " ""}{emit_handler !handlers}\n`
      end
    | Istackoffset(_) ->
      assert false
    | Iload(size, addr) ->
      let instr = match size with
        | Byte_unsigned      -> "1.u64"
        | Byte_signed        -> "1.i64"
        | Sixteen_unsigned   -> "2.u64"
        | Sixteen_signed     -> "2.i64"
        | Thirtytwo_unsigned -> "4.u64"
        | Thirtytwo_signed   -> "4.i64"
        | Word_int           -> "8.u64"
        | Word_val           -> "8.u64"
        | Single             -> "4.f64"
        | Double             -> "8.f64"
        | Double_u           -> "8.f64"
      in
      (match addr with
      | Iindexed(0) ->
        `  ld.{emit_string instr} {emit_reg res.(0)}, [{emit_reg arg.(0)}]\n`
      | Iindexed(n) ->
        let imm = emit_const n in
        let addr = make_temp () in
        `  add.i64 {emit_temp addr}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  ld.{emit_string instr} {emit_reg res.(0)}, [{emit_temp addr}]\n`
      )
    | Istore(size, addr, _) ->
      let instr = match size with
        | Byte_unsigned      | Byte_signed        -> "1"
        | Sixteen_unsigned   | Sixteen_signed     -> "2"
        | Thirtytwo_unsigned | Thirtytwo_signed   -> "4"
        | Word_int           | Word_val           -> "8"
        | Single   -> "8"
        | Double   -> "8"
        | Double_u -> "8"
      in
      (match addr with
      | Iindexed(0) ->
        `  st.{emit_string instr} [{emit_reg arg.(1)}], {emit_reg arg.(0)}\n`
      | Iindexed(n) ->
        let imm = emit_const n in
        let addr = make_temp () in
        `  add.i64 {emit_temp addr}, {emit_reg arg.(1)}, {emit_temp imm}\n`;
        `  st.{emit_string instr} [{emit_temp addr}], {emit_reg arg.(0)}\n`
      );
    | Ialloc { words } ->
      if fast && !inline_alloc then begin
        let gc_ret = new_label () in
        let gc_lbl = new_label () in
        `{emit_label gc_ret}:\n`;
        let young_lim = make_temp () in
        let young_ptr = make_temp () in
        let new_ptr = make_temp () in
        let flag = make_temp () in
        let immw = emit_const words in
        let addr_young_lim = emit_addr "caml_young_limit" in
        let addr_young_ptr = emit_addr "caml_young_ptr" in
        `  ld.8.i64 {emit_temp young_lim}, [{emit_temp addr_young_lim}]\n`;
        `  ld.8.i64 {emit_temp young_ptr}, [{emit_temp addr_young_ptr}]\n`;
        `  sub.i64 {emit_temp new_ptr}, {emit_temp young_ptr}, {emit_temp immw}\n`;
        `  cmp.lt.i32 {emit_temp flag}, {emit_temp new_ptr}, {emit_temp young_lim}\n`;
        `  jt {emit_temp flag}, {emit_label gc_lbl}\n`;
        let imm8 = emit_const 8 in
        `  add.i64 {emit_reg res.(0)}, {emit_temp young_ptr}, {emit_temp imm8}\n`;
        gc_sites := { gc_lbl; gc_ret; gc_exc = !handlers } :: !gc_sites
      end else begin
        let args = match words with
          | 16 -> [emit_addr "caml_alloc1"]
          | 24 -> [emit_addr "caml_alloc2"]
          | 32 -> [emit_addr "caml_alloc3"]
          | _  -> [emit_addr "caml_allocN"; emit_const words]
        in
        `  {emit_call !handlers}.i64.c {emit_reg res.(0)}, {emit_temps args}{emit_handler !handlers} @caml_call_frame\n`
      end
    | Iintop(op) ->
      emit_intop res arg (fun () -> emit_reg arg.(1)) op
    | Iintop_imm(op, n) ->
      let imm = emit_const n in
      emit_intop res arg (fun () -> emit_temp imm) op
    | Inegf ->
      `  neg.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`;
    | Iabsf ->
      `  abs.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`;
    | Iaddf ->
      `  add.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
    | Isubf ->
      `  sub.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
    | Imulf ->
      `  mul.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
    | Idivf ->
      `  div.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
    | Ifloatofint ->
      `  mov.f64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`;
    | Iintoffloat ->
      `  mov.i64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`;
    | Ispecific(_) ->
      assert false
    | Iname_for_debugger(_) ->
      assert false
  in

  let emit_instr arg res = function
    | Lend ->
      ()
    | Lop(Imove) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_reg arg.(0)}\n`
    | Lop(Iconst_int n) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_int (Nativeint.to_int n)}\n`
    | Lop(Iconst_symbol s) ->
      `  mov.i64 {emit_reg res.(0)}, {emit_symbol s}\n`
    | Lop(op) ->
      emit_op arg res op
    | Lreloadretaddr ->
      ()
    | Lreturn ->
      let nargs = Array.length arg in
      let types = String.concat "" (List.init nargs (fun _ -> ".i64")) in
      `  ret{emit_string types}{emit_regs arg " " ""}\n`;
    | Llabel(label) ->
      current_block := label;
      `{emit_label label}:\n`
    | Lbranch(label) ->
      `  jmp {emit_label label}\n`
    | Lcondbranch(test, label) ->
      (match test with
      | Itruetest ->
        let flag = make_temp () in
        `  trunc.i32.i64 {emit_temp flag}, {emit_reg arg.(0)}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Ifalsetest ->
        let flag = make_temp () in
        `  trunc.i32.i64 {emit_temp flag}, {emit_reg arg.(0)}\n`;
        `  jf {emit_temp flag}, {emit_label label}\n`
      | Iinttest cc ->
        let flag = make_temp () in
        `  cmp.{emit_cc cc}.i32 {emit_temp flag}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Iinttest_imm(cc, n) ->
        let imm = emit_const n in
        let flag = make_temp () in
        `  cmp.{emit_cc cc}.i32 {emit_temp flag}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Ifloattest(cc) ->
        let cond = match cc with
          | CFeq  -> "oeq"
          | CFneq -> "une"
          | CFlt  -> "olt"
          | CFnlt -> "ugt"
          | CFgt  -> "ogt"
          | CFngt -> "ule"
          | CFle  -> "ole"
          | CFnle -> "ugt"
          | CFge  -> "oge"
          | CFnge -> "ult"
        in
        let flag = make_temp () in
        `  cmp.{emit_string cond}.i32 {emit_temp flag}, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Ioddtest ->
        let imm = emit_const 1 in
        let flag = make_temp () in
        `  and.i64 {emit_temp flag}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  jt {emit_temp flag}, {emit_label label}\n`
      | Ieventest ->
        let imm = emit_const 1 in
        let flag = make_temp () in
        `  and.i64 {emit_temp flag}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
        `  jf {emit_temp flag}, {emit_label label}\n`
      );
    | Lcondbranch3(lbl_lt, lbl_eq, lbl_gt) ->
        let imm = emit_const 1 in
        let flag = make_temp () in
        let emit cc lbl =
          `  cmp.{emit_string cc}.i32 {emit_temp flag}, {emit_reg arg.(0)}, {emit_temp imm}\n`;
          `  jt {emit_temp flag}, {emit_label lbl}\n`
        in
        lbl_lt |> Option.iter (emit "lt");
        lbl_eq |> Option.iter (emit "eq");
        lbl_gt |> Option.iter (emit "gt")
    | Lswitch(labels) ->
      `  switch {emit_reg arg.(0)}, `;
      let n = Array.length labels in
      Array.iteri (fun i l ->
        `{emit_label l}`;
        if i + 1 <> n then `, ` else ()
      ) labels;
      `\n`
    | Lsetuptrap(label) ->
      let handler = new_label () in
      Hashtbl.add traps label handler;
      let exn_addr = make_temp () in
      let jmp_frame = make_temp () in
      let val_addr = make_temp () in
      let trap_idx = List.length !handlers * 3 * 8 in
      `  mov.i64 {emit_temp exn_addr}, {emit_label handler}\n`;
      `  frame.i64 {emit_temp jmp_frame}, {emit_int (trap_idx + 0)}\n`;
      `  st.8 [{emit_temp jmp_frame}], {emit_temp exn_addr}\n`;
      `  jmp {emit_label label}\n`;
      `{emit_label handler}:\n`;
      `  mov.i64 {emit_temp val_addr}, caml_exn_val\n`;
      `  ld.8.i64 {emit_reg Proc.loc_exn_bucket}, [{emit_temp val_addr}]\n`
    | Lpushtrap ->
      let handler =
        try Hashtbl.find traps !current_block
        with Not_found -> 0
      in
      let trap_idx = List.length !handlers * 3 * 8 in
      handlers := handler :: !handlers;
      let exc_addr = emit_addr "caml_exception_pointer" in
      let jmp_frame = make_temp () in
      let sp_frame = make_temp () in
      let exc_frame = make_temp () in
      let exc_val = make_temp () in
      let sp_val = make_temp () in
      `  frame.i64 {emit_temp jmp_frame}, {emit_int (trap_idx + 0)}\n`;
      `  frame.i64 {emit_temp sp_frame}, {emit_int (trap_idx + 8)}\n`;
      `  frame.i64 {emit_temp exc_frame}, {emit_int (trap_idx + 16)}\n`;
      `  ld.8.u64 {emit_temp exc_val}, [{emit_temp exc_addr}]\n`;
      `  st.8 [{emit_temp exc_frame}], {emit_temp exc_val}\n`;
      `  mov.i64 {emit_temp sp_val}, $sp\n`;
      `  st.8 [{emit_temp sp_frame}], {emit_temp sp_val}\n`;
      `  st.8 [{emit_temp exc_addr}], {emit_temp jmp_frame}\n`
    | Lpoptrap ->
      handlers := List.tl !handlers;
      let trap_idx = List.length !handlers * 3 * 8 in
      let exc_addr = emit_addr "caml_exception_pointer" in
      let exc_val = make_temp () in
      let exc_frame = make_temp () in
      `  frame.i64 {emit_temp exc_frame}, {emit_int (trap_idx + 16)}\n`;
      `  ld.8.i64 {emit_temp exc_val}, [{emit_temp exc_frame}]\n`;
      `  st.8 [{emit_temp exc_addr}], {emit_temp exc_val}\n`
    | Lraise(raise) ->
      (match raise with
      | Cmm.Raise_notrace when !inline_raise && no_handler () ->
        let exc_val = make_temp () in
        let ret_val = make_temp () in
        let jmp_frame = make_temp () in
        let sp_frame = make_temp () in
        let exc_frame = make_temp () in
        let next_sp = make_temp () in
        let offset = emit_const 8 in
        let exc_addr = emit_addr "caml_exception_pointer" in
        let val_addr = emit_addr "caml_exn_val" in

        (* Store the exception being raised. *)
        `  st.8 [{emit_temp val_addr}], {emit_reg arg.(0)}\n`;

        `  ld.8.i64 {emit_temp jmp_frame}, [{emit_temp exc_addr}]\n`;
        `  add.i64 {emit_temp sp_frame}, {emit_temp jmp_frame}, {emit_temp offset}\n`;
        `  add.i64 {emit_temp exc_frame}, {emit_temp sp_frame}, {emit_temp offset}\n`;

        `  ld.8.i64 {emit_temp next_sp}, [{emit_temp sp_frame}]\n`;
        `  set.i64 $sp, {emit_temp next_sp}\n`;

        `  ld.8.i64 {emit_temp exc_val}, [{emit_temp exc_frame}]\n`;
        `  st.8 [{emit_temp exc_addr}], {emit_temp exc_val}\n`;

        `  ld.8.i64 {emit_temp ret_val}, [{emit_temp jmp_frame}]\n`;
        `  ji {emit_temp ret_val}\n`
      | Cmm.Raise_notrace when !inline_raise ->
        (* TODO: not implemented *)
        assert false
      | _ when no_handler () ->
        let exn = emit_addr "caml_raise_exception" in
        `  tcall.c {emit_temp exn}{emit_regs arg ", " ""} @caml_raise_frame\n`;
      | _ ->
        let exn = emit_addr "caml_raise_exception" in
        `  tinvoke.c {emit_temp exn}{emit_regs arg ", " ""}{emit_handler !handlers} @caml_raise_frame\n`;
      )
  in
  let rec emit = function
    | { desc = Lend } -> ()
    | instr ->
      emit_instr instr.arg instr.res instr.desc;
      emit instr.next
  in

  let rec sizeof_frame n m = function
    | { desc = Lend } -> m
    | { desc = Lpushtrap; next } -> sizeof_frame (n + 1) (max (n + 1) m) next
    | { desc = Lpoptrap; next } -> sizeof_frame (n - 1) m next
    | { next } -> sizeof_frame n m next
  in

  let frame_size = 8 * 3 * sizeof_frame 0 0 body in
  if frame_size <> 0 then
    `  .stack {emit_int frame_size}\n`;

  find_regs body;
  let arg_list = List.sort (fun (i1, _, _) (i2, _, _) -> compare i1 i2) (
      Hashtbl.fold (fun arg (idx, ty) acc -> (idx, arg, ty) :: acc) params []
  ) in
  `  .args 0`;
  arg_list |> List.iter (fun (_, _, ty) -> `, {emit_string ty}`);
  `\n`;
  arg_list |> List.iter (fun (idx, arg, ty) ->
    `  arg.{emit_string ty} ${emit_int arg}, {emit_int idx}\n`
  );

  emit body;

  (* Emit calls to all GC sites *)
  !gc_sites |> List.iter (fun { gc_lbl; gc_ret } ->
    `{emit_label gc_lbl}:\n`;
    let addr = emit_addr "caml_call_gc" in
    `  call.c {emit_temp addr} @caml_call_frame\n`;
    `  jmp {emit_label gc_ret}\n`
  );

  (* Emit bound error call *)
  !bound_error_labels |> List.iter (fun (handler, label) ->
    `{emit_label label}:\n`;
    let addr = emit_addr "caml_ml_array_bound_error" in
    match handler with
    | None   -> `  tcall.c {emit_temp addr}\n`
    | Some h -> `  tinvoke.c {emit_temp addr}, {emit_label h}\n`
    )

let data items =
  `  .data\n`;
  `  .p2align 3\n`;
  items |> List.iter (function
  | Cstring s          -> emit_string_directive "  .ascii  " s
  | Cskip n            -> if n > 0 then `  .space   {emit_int n}\n`
  | Cdefine_symbol s   -> `{emit_symbol s}:\n`
  | Cglobal_symbol s   -> `  .globl   {emit_symbol s}\n`
  | Calign n           -> `  .p2align {emit_int n}\n`
  | Cint8 n            -> `  .byte    {emit_int n}\n`
  | Cint16 n           -> `  .short   {emit_int n}\n`
  | Cint32 n           -> `  .long    {emit_int (Nativeint.to_int n)}\n`
  | Cint n             -> `  .quad    {emit_int (Nativeint.to_int n)}\n`
  | Csymbol_address s  -> `  .quad    {emit_symbol s}\n`
  | Csingle f          -> `  .float   {emit_printf "0x%Lx\n" (Int64.bits_of_float f)}\n`
  | Cdouble f          -> `  .double  {emit_printf "0x%Lx\n" (Int64.bits_of_float f)}\n`
  );
  `\n`

let fundecl f =
  `  .text\n`;
  `  .globl {emit_symbol f.fun_name}\n`;
  `{emit_symbol f.fun_name}:\n`;
  `  .call ocaml\n`;
  emit_linear f.fun_fast f.fun_body;
  `\n`

let begin_assembly () =
  ()

let end_assembly () =
  ()

